Files:

1) Node class

    Variables:
    identityIP, buffer, backofftime, noOfCollisions, lostPacketCount(due to buffer overflows),
    successPacketCount, numberOfGeneratedPackets, retransmittedPacketCount, probability,
    facedCollision = false, delayedTimeSlots


    Methods:
    1) getNumberOfGeneratedPackets
    2) generatePacketsWithProbability
        #if buffer is full, increase lostPacketCount,
    3) removePacketAndUpdateVariables
        #when removing a packet, if (facedCollision==true) retransmittedPacketCount++ && retransmissionCount
        #when removing a packet, check how many time slots it has waited since it was generated and maintain a variable in
        every node that keeps track of the delay component
    4)

    //when there is generation of a packet, initialize a delay variable

2) Driver file

    Variables:
    throughput

        Fetch from user:
        simulationTime
        bufferSize
        probabilityValue
        numberOfNodes
        successfulslots (meaning in a timeslot, if the channel is in transmission mode, successfulslots++)
        wasteslots (meaning in a timeslot, if the channel is in idle or collission mode, wasteslots++)


    Methods:

    1) *int countOfAllThePackets* getTotalPacketsGenerated(array of nodes)

    2) *int averageCountOfAllThePackets* getTotalAverageOfPacketsGenerated(array of nodes)

    3) *int countOfTotalVariables* getFrameLoss(array of nodes)
         #for every node, add(fetch ( lostPacketCount + retransmittedPacketCount))

    4) *int countOfAwaitingFrames* getTotalAwaitingFrames(array of nodes)
         #for every node, add(bufferSize)

    5)  *int countOfTotalVariables* getChannelWaste(array of nodes)
         #for every node, add(fetch ( lostPacketCount + retransmittedPacketCount))

    6) *int countOfDelayComponents* getAverageDelay(array of nodes)
         #for every node, add delay components divided by total packets generated by each node.





/*        """ for (int i = 0; i < timeSlots; i++) {

			// generate packets
			for (int j = 0; j < node.length; j++) {
				node[j].generatePacket();//generate packet with probability of 0.1
				//decrease backoff time if it is not 0
			}

			// check how many nodes have packet to be transmitted

				//if only one node has packet && its backoff time is 0 && channel is idle (state:transmission)
			    	//channel state = transmission
			        //for that node, decrease the buffer size by 1, call a method (node.removePacket&DecreaseBuffersize)
			        //transcount = 10 (because channel is occupied for 10 time slots)
			        //change the channel state to idle when transcount is 0
			        //update other statistics variables here

				//else if channel is idle && more than one nodes have packets (state:contention)
			        //channel state = contention
			        //for every node, update collision and backoff variables, call a method (node.updateBackoffVariables)

			    //else if there are no packets to be sent in  any of the nodes && transcount is 0
			        //channel state = idle

			//transcount--
		}


	 * This method takes array of nodes as input, checks if any nodes have pending
	 * packets, returns an arraylist of nodes which have pending packets.
	 *
	 * @param array of nodes
	 * @param max
	 * @return arraylist of nodes

	"""

